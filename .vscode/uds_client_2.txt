import udsoncan
from udsoncan.services import SecurityAccess
from udsoncan.connections import PythonIsoTpConnection
from udsoncan.client import Client
import udsoncan.configs
import isotp
import can
import logging
import os
import time

# Setup CAN interface and connection
os.system('sudo ip link set can0 down')
os.system('sudo ip link set can0 up type can bitrate 500000 dbitrate 1000000 restart-ms 1000 berr-reporting on fd on')  # Set bitrate to 500kbps
os.system('sudo ifconfig can0 up')

# Logging setup
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s [%(levelname)s] %(message)s')

# Define ISO-TP parameters for CAN FD with 11-bit identifiers
isotp_params = {
    'stmin': 32,
    'blocksize': 8,
    'wftmax': 0,
    'tx_data_length': 8, 
    'tx_padding': 0x00,
    'rx_flowcontrol_timeout': 1000,
    'rx_consecutive_frame_timeout': 1000,
    'max_frame_size': 4095,
    'can_fd': True,    
    'bitrate_switch': True
}

# UDS Client Configuration
config = dict(udsoncan.configs.default_client_config)
config["ignore_server_timing_requirements"] = True
config["data_identifiers"] = {
    0xF187: udsoncan.AsciiCodec(13),
    0xF1AA: udsoncan.AsciiCodec(7),
    0xF1B1: udsoncan.AsciiCodec(7),
    0xF193: udsoncan.AsciiCodec(7) 
}

# Define CAN interface
interface = "can0"

# Create CAN bus interface
bus = can.interface.Bus(channel=interface, bustype="socketcan", fd=True)
bus.set_filters([{"can_id":0x7A8,"can_mask":0xFFF}])

# Define ISO-TP addressing for 11-bit CAN IDs
tp_addr = isotp.Address(isotp.AddressingMode.Normal_11bits, txid=0x7A0, rxid=0x7A8)

# Create ISO-TP stack
stack = isotp.CanStack(bus=bus, address=tp_addr, params=isotp_params)

# Create UDS connection
conn = PythonIsoTpConnection(stack)

# Start UDS Client
with Client(conn, request_timeout=5, config=config) as client:
    logging.info("UDS Client Started")
    print(type(client))

    # Tester Present (0x3E)
    try:
        client.tester_present()
        logging.info("Tester Present sent successfully")
    except Exception as e:
        logging.warning(f"Tester Present failed: {e}")

    # Default Session (0x10 0x01)
    try:
        response = client.change_session(0x01)
        if response.positive:
            logging.info("Switched to Default Session")
        else:
            logging.warning("Failed to switch to Default Session")
    except Exception as e:
        logging.error(f"Error in Default Session: {e}")

    # Extended Session (0x10 0x03)
    try:
        response = client.change_session(0x03)
        if response.positive:
            logging.info("Switched to Extended Session")
        else:
            logging.warning("Failed to switch to Extended Session")
    except Exception as e:
        logging.error(f"Error in Extended Session: {e}")
        
    # Security Access (0x27)
    try:
        subfunc_int = 0xF187
        security_level = 0x11
        
        # Step 1: Request Seed
        response = client.send_request(SecurityAccess, subfunction=subfunc_int)
        if response.positive:
            seed = response.service_data.seed
            logging.info(f"-> Security Level {security_level} Seed: {seed.hex()}")

            # Step 2: Call external DLL or socket for seed-to-key
            # For testing, you can hardcode a key:
            key = b'\x01\x02\x03\x04\x05\x06\x07\x08'  # Replace with a valid key
            logging.info(f" -> Hardcoded Key for Level {security_level}: {key.hex()}")

            # Step 3: Send Key
            key_response = client.send_request(SecurityAccess, subfunction=subfunc_int + 1, data=key)
            if not key_response.positive:
                raise Exception(f"-> Key Response Failed (Level {security_level}): NRC={hex(key_response.code)}")
            else:
                logging.info(f"> SecurityAccess Level {security_level} Successful")

        else:
            raise Exception(f" -> Seed Request Failed (Level {security_level}): NRC={hex(response.code)}")

    except Exception as e:
        # Handle and log the error
        logging.error(f"-> SecurityAccess Error: {e}")

logging.info("UDS Client Closed")
