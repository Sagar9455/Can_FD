import os
import shutil
import time
import logging
from datetime import datetime

class USBTransfer:
    def __init__(self, oled):
        self.oled = oled
        self.outputs_folder = "/home/mobase/Can_FD/Outputs"
        self.usb_root = "/media"
        logging.info("USBTransfer initialized")

    def show_progress_animation(self, base_msg, duration=3, interval=0.5):
        steps = int(duration / interval)
        for i in range(steps):
            dots = '.' * ((i % 3) + 1)
            self.oled.display_centered_text(f"{base_msg}{dots}")
            time.sleep(interval)

    def get_usb_mount_path(self):
        logging.info(f"Scanning for USB under {self.usb_root}")
        try:
            for user_folder in os.listdir(self.usb_root):
                user_path = os.path.join(self.usb_root, user_folder)
                logging.debug(f"Checking user folder: {user_path}")
                if os.path.isdir(user_path):
                    for device in os.listdir(user_path):
                        mount_path = os.path.join(user_path, device)
                        logging.debug(f"Checking device mount: {mount_path}")
                        if os.path.ismount(mount_path):
                            logging.info(f"USB mount found at: {mount_path}")
                            return mount_path
        except Exception as e:
            logging.error(f"Error during USB scanning: {str(e)}")
        logging.warning("No USB mount found")
        return None

    def transfer_files_to_usb(self):
        try:
            self.oled.display_centered_text("Looking for USB...")
            logging.info("Starting USB transfer process")
            time.sleep(1)

            usb_path = self.get_usb_mount_path()
            if not usb_path:
                self.oled.display_centered_text("No USB found!")
                logging.warning("USB device not found")
                time.sleep(2)
                return

            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_folder = os.path.join(usb_path, f"UDS_Backup_{timestamp}")
            os.makedirs(backup_folder, exist_ok=True)
            logging.info(f"Backup folder created: {backup_folder}")

            self.oled.display_centered_text("USB Found.\nTransferring...")
            self.show_progress_animation("Copying", duration=3)

            folders_to_copy = ["html_reports", "asc_logs"]
            total_files = 0

            for folder_name in folders_to_copy:
                src_path = os.path.join(self.outputs_folder, folder_name)
                dest_path = os.path.join(backup_folder, folder_name)

                if not os.path.exists(src_path):
                    logging.warning(f"Source folder not found: {src_path}")
                    continue

                shutil.copytree(src_path, dest_path)
                files_in_folder = sum(len(files) for _, _, files in os.walk(dest_path))
                total_files += files_in_folder

                logging.info(f"Copied '{folder_name}' to USB ({files_in_folder} files)")

            self.oled.display_centered_text(f"Transfer Done\n{total_files} files")
            logging.info(f"Transfer complete. Total files copied: {total_files}")
            time.sleep(2)

        except Exception as e:
            error_msg = f"Error during transfer: {str(e)}"
            self.oled.display_centered_text(f"Error:\n{str(e)[:20]}")
            logging.error(error_msg)
            time.sleep(3)

#####




import requests

# Change 'PC_IP_ADDRESS' to the actual IP address of the PC running the Flask server
pc_ip_address = "PC_IP_ADDRESS"  # Replace with the PC's IP address
url = f"http://{pc_ip_address}:5000/trigger"

# Send a POST request to the Flask server on the PC
response = requests.post(url)

# Print the response from the PC
print("Response from PC:", response.json())

192.168.10.220
####


import requests

url = "http://192.168.1.100:5000/trigger"  # Replace with your Windows IP

try:
    response = requests.post(url)
    if response.ok:
        print("Response from CANoe:", response.json()["canoe_response"])
    else:
        print("Error:", response.status_code)
except Exception as e:
    print("Failed to connect:", e)
####



import sys
import os
import time
import logging
import RPi.GPIO as GPIO
import shutil  # For checking disk space

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from drivers import oled_display, button_input, config_loader, uds_client, usb_transfer
from drivers.report_generator import ReportGenerator

print(sys.path)

# Load config
config = config_loader.load_config("config.json")

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[logging.FileHandler("uds_debug.log"), logging.StreamHandler()]
)

# Bring up CAN interface 
if config.get("can_interface", {}).get("bringup_on_startup", False):
    bitrate = config["can_interface"].get("bitrate", 500000)
    dbitrate = config["can_interface"].get("dbitrate", 1000000)
    restart_ms = config["can_interface"].get("restart_ms", 1000)
    os.system(f"sudo ip link set can0 down")
    os.system(f"sudo ip link set can0 up type can bitrate {bitrate} dbitrate {dbitrate} restart-ms {restart_ms} berr-reporting on fd on")
    os.system("sudo ifconfig can0 up")
    logging.info("CAN interface can0 brought up")

# Setup OLED and buttons
oled = oled_display.OLEDDisplay(config["display"])
btn_map = config["gpio"]["buttons"]
BTN_FIRST = btn_map["first"]
BTN_SECOND = btn_map["second"]
BTN_ENTER = btn_map["enter"]
BTN_THANKS = btn_map["thanks"]

buttons = button_input.ButtonInput(list(btn_map.values()))
uds = uds_client.UDSClient(config)
usb = usb_transfer.USBTransfer(oled)  # USB transfer class

menu_combinations = config["menu_combinations"]

# Function to display text on the OLED
def show_text(text):
    oled.clear()
    oled.display_text(text)

# Function to check disk space
def check_disk_space(min_required_mb=50):
    total, used, free = shutil.disk_usage("/")
    free_mb = free // (1024 * 1024)  # Convert to MB
    return (free_mb >= min_required_mb, free_mb)

min_required = 50
enough_space, free_mb = check_disk_space(min_required_mb=min_required)

if not enough_space:
    warning_msg = f"Low Storage!\nOnly {free_mb}MB left.\nNeed {min_required}MB."
    oled.display_text(warning_msg)
    logging.warning(warning_msg)
    time.sleep(4)
else:
    oled.display_text(f"Storage OK\nFree: {free_mb} MB")
    logging.info(f"Storage check passed: {free_mb} MB available")
    time.sleep(2)

# Welcome screen (centered)
oled.display_centered_text("Welcome\nto\nDiagnostics")
time.sleep(2)

# Prompt screen (centered)
oled.display_centered_text("Select Option:")
time.sleep(1)

# Main loop
while True:
    show_text("- Read ECU Info\n- Run Test cases\n- ECU Updater\n- Transfer Files")

    selected_sequence = []
    variable = 0
    varFinal = 0

    # Combo input mode
    while True:
        if GPIO.input(BTN_FIRST) == GPIO.LOW:
            selected_sequence.append(BTN_FIRST)
            variable = (variable * 10) + 1
            show_text(str(variable))
            time.sleep(0.3)

        if GPIO.input(BTN_SECOND) == GPIO.LOW:
            selected_sequence.append(BTN_SECOND)
            variable = (variable * 10) + 2
            show_text(str(variable))
            time.sleep(0.3)

        if GPIO.input(BTN_ENTER) == GPIO.LOW:
            varFinal = variable
            variable = 0
            selected_sequence.append(BTN_ENTER)
            key = str(tuple(selected_sequence))
            print(f"Captured sequence: {selected_sequence}")
            print(f"key string used : {str(tuple(selected_sequence))}")
            selected_option = menu_combinations.get(key, "Invalid Input")
            show_text(f"{selected_option}")
            time.sleep(0.5)

            if selected_option == "ECU Information":
                show_text("Fetching ECU Info...")
                uds.get_ecu_information(oled)
                show_text("Done")
                time.sleep(2)

            elif selected_option == "Testcase Execution":
                show_text("Running Testcases...")
                time.sleep(2)
                uds.run_testcase(oled)
                show_text("Done")
                time.sleep(2)

            elif selected_option == "Reserved1\nfor future versions":
                show_text("Reserved1\nfor future versions")
                time.sleep(2)
                show_text("Done")
                time.sleep(2)

            elif selected_option == "Reserved2\nfor future versions":
                show_text("Reserved2\nfor future versions")
                time.sleep(2)
                show_text("Done")
                time.sleep(2)

            elif selected_option.startswith("File Transfer"):
                show_text("Transferring logs...")
                time.sleep(2)
                usb.transfer_files_to_usb()  # Call the transfer function
                show_text("Done")
                time.sleep(2)

            elif selected_option == "Exit":
                show_text("Exiting...")
                time.sleep(1)
                os.system("exit")

            break  # exit sequence input loop

        if GPIO.input(BTN_THANKS) == GPIO.LOW:
            show_text("Shutting Down")
            time.sleep(2)
            GPIO.cleanup()
            os.system("sudo poweroff")

        time.sleep(0.1)
####



import os
import shutil
import time

class USBTransfer:
    def __init__(self, oled):
        self.oled = oled  # Store the oled display instance
        self.log_folder = "/home/mobase/Can_FD/Report"  # Folder containing the log files
        self.usb_root = "/media/mobase"  # Path where USB is mounted

    # Progress Animation
    def show_progress_animation(self, base_msg, duration=3, interval=0.5):
        """
        Displays a progress animation on the OLED screen.
        """
        steps = int(duration / interval)
        for i in range(steps):
            dots = '.' * ((i % 3) + 1)
            self.oled.display_centered_text(f"{base_msg}{dots}")
            time.sleep(interval)

    # Check if USB is mounted
    def check_usb_mount(self):
        """
        Checks if the USB drive is mounted.
        """
        if os.path.ismount(self.usb_root):
            return True
        return False

    # Transfer files to USB
    def transfer_files_to_usb(self):
        """
        Transfers log files from the local folder to the USB drive.
        """
        try:
            # Check if USB is mounted
            self.oled.display_centered_text("Looking for USB...")
            time.sleep(2)

            if not self.check_usb_mount():
                self.oled.display_centered_text("USB not found.\nPlease connect USB.")
                time.sleep(3)
                return

            # Proceed with the transfer
            self.show_progress_animation("Transferring logs", duration=5)

            # Create directory on USB if it doesn't exist
            usb_log_folder = os.path.join(self.usb_root, "Logs")
            if not os.path.exists(usb_log_folder):
                os.makedirs(usb_log_folder)

            # Transfer the files from the local log folder to USB
            files_to_copy = os.listdir(self.log_folder)
            if not files_to_copy:
                self.oled.display_centered_text("No files to transfer.")
                time.sleep(2)
                return

            # Transfer each file
            for file_name in files_to_copy:
                source_file = os.path.join(self.log_folder, file_name)
                destination_file = os.path.join(usb_log_folder, file_name)
                
                # Check if the file exists in the destination
                if os.path.exists(destination_file):
                    self.oled.display_centered_text(f"File {file_name} exists.\nSkipping.")
                    time.sleep(1)
                    continue

                # Perform the file transfer
                shutil.copy(source_file, destination_file)
                self.oled.display_centered_text(f"Transferred: {file_name}")
                time.sleep(1)

            self.oled.display_centered_text("Transfer Complete!")
            time.sleep(2)

        except Exception as e:
            # In case of an error
            self.oled.display_centered_text(f"Error: {str(e)[:20]}")
            time.sleep(4)






